# Luscii ‚Äì Technical Assignment

## üìö Description

This is a simple API for managing notes. It supports adding, listing, and deleting notes.  
It was built using Node.js with in-memory storage for demonstration purposes.

---

## Requirements

The application should meet the following requirements:

- Use Node.js
- Use in-memory storage (no database required)
- Handle errors securely
- Include unit tests
- Clear and maintainable code

Implicit from the context:

- Secure
- Scalable
- Serverless environment

## Endpoints

The app will have the following endpoints:

- `POST /notes` - Create a new note
- `GET /notes` - Get all notes
- `DELETE /notes/:id` - Delete a note by ID

Full API specification can be found in [api-spec.MD](./api-spec.MD).

## üõ†Ô∏è How to run

```bash
# Install dependencies
npm install

# Run the API
npm start

# Run tests
npm test

# Format code with Prettier
npm run format
```

## Contributing

### Getting Started

If you want to quickly get started, use vs code and have docker installed you can use the devcontainer to get an environment ready to go. Just run the "Reopen in Container" command from the command palette.

### Pull Requests

Use pull requests to propose and submit changes to the codebase. Ensure your changes are well-documented and tested. Pull requests will be required to be squashed and merged to keep the commit history clean.

Each commit will be prefixed to denote the type of change:

- `[FEAT]:` for new features
- `[FIX]:` for bug fixes
- `[DOCS]:` for documentation changes
- `[STYLE]:` for code style changes
- `[REFAC]:` for code refactoring
- `[TEST]:` for adding or updating tests
- `[DEV]:` for development environment changes

### Code style

Usually I would use a linter like ESLint to maintain code style consistency in line with how the organization handles code style (since it is fairly configurable to the organization's preferences). For demonstration purposes we use prettier with default settings. This gives consistent formatting, without a lot of configuration.

### Pipeline

A simple CI pipeline is set up using GitHub Actions to run tests and format checks on each pull request.

## Assumptions and Decisions

This section outlines some assumptions and decisions made during development. Some of these would normally be clarified with e.g. the product owner.

- The maximum length for a note's content is 1000 characters. For now an arbitrary limit is set to prevent excessively large notes.
- Based on the initial tests a note has a content field (string) and an id (string). For the demo purposes we assume no other fields (like createdAt, updatedAt, title, tags, etc.) are needed.
- The id is an UUID generated by the server. With an UUID we avoid collisions in a simple way.
- Empty notes are not allowed.
- I did not bother with error logging for the demo version, but in a production system we would log errors to a logging service for monitoring and debugging.
- I implemented a simple cleaning middleware to trim whitespace from note content before saving.
- I did not implement more complex sanitation in the demo which might be needed in the real context.
- Attempting to delete a note that does not exist returns a 404 error.
- In the demo version I did not implement proper error types in the code. To the outside the API handles errors correctly to the spec. For extendability and maintainability it could be an improvement to have custom error classes to represent different error types.
- In the demo version the get does not have pagination, sorting or filtering of any type.
- In the demo version deployment is not implemented in any way, but the code is structured to be easily deployable to serverless environments like AWS Lambda when a database is implemented and deployment pipelines are set up.
- There are clear interfaces for the repository and service layers to allow easy swapping of implementations in the future and for injection when testing. The functions are async to allow easy integration with databases or external services later.

## üóÇÔ∏è Code Structure

- **src/** ‚Äì Main application source code
  - **index.ts** ‚Äì Express app setup and route registration
  - **middleware.ts** ‚Äì All validation, cleaning, and error handler middleware
  - **notesRepository.ts** ‚Äì In-memory repository class for notes
  - **notesService.ts** ‚Äì Business logic for notes (service class)
  - **types.ts** ‚Äì Shared TypeScript interfaces and types
- **tst/** ‚Äì Test suite
  - **notes.*.test.ts** ‚Äì Unit tests for each endpoint
  - **testUtils.ts** ‚Äì Test helpers and test app factory
- **api-spec.MD** ‚Äì API specification and contract
- **readme.MD** ‚Äì Project documentation

This modular structure makes it easy to extend, test, and maintain the codebase.

## Future

### How to impelement using AWS Lambda and DynamoDB
If in the future this would be impelemented using AWS Lambda and DynamoDB, roughly the following steps are required:
1. **Create a new repository implementation**: Implement a new `DynamoDBNotesRepository` class that adheres to the `NotesRepository` interface, using AWS SDK to interact with DynamoDB.
2. **Update dependency injection**: Modify the application setup to inject `DynamoDBNotesRepository` instead of `InMemoryNotesRepository`.
3. **Make app compatible with Lambda**: Refactor the Express app to be compatible with AWS Lambda using a library like `aws-serverless-express`.
4. **Integration tests**: Ensure there are integration tests that test the full stack with DynamoDB and Lambda.
4. **Set up AWS resources**: In the manner used within the team/organization, set up the necessary AWS resources (e.g. Terraform).
5. **Configure the deployment pipeline**: Set up the CI/CD pipeline to deploy the Lambda function and DynamoDB table. Also ensure environment variables and permissions are correctly configured.

### Adding authentication in the future
Assuming: user authentication (so personal notes per user), using AWS Cognito for authentication and authorization, and we have setup the app t owork with AWS Lambda and DynamoDB.
To add authentication in the future, roughly the following steps would have be taken:
1. **Update the API spec**: Modify the API specification to include authentication requirements.
2. **Update the code (including required tests)**: 
   - Add authentication middleware to verify JWT tokens from AWS Cognito.
   - Modify the `NotesRepository` and `NotesService` to associate notes with user IDs.
   - Update endpoints to to require authentication according to spec.
   - Update app to extract the user information when using Lambda.
3. **Setup AWS resources**: Ensure AWS Cognito is set up correctly with terraform. This configuration will depend on what is already configured for users in the real context.
4. **Update deployment pipeline**: Ensure the deployment pipeline includes any necessary steps and environment variables to configure AWS Cognito and update Lambda permissions if needed.

### Documenting and sharing the API in a real team setting.
In a real team setting, to document and share the API effectively, these are some recommended steps:
1. **Use an API documentation tool**: Utilize tools like Swagger to properly document the API endpoints, request/response formats, and error codes.
2. **Host the documentation**: Make the API documentation easily accessible to the team, e.g., hosting it on a shared Confluence page or a dedicated API documentation site.
3. **Versioning**: Implement API versioning to manage changes and ensure backward compatibility.
4. **Issue tracking**: Use an issue tracking system (like Jira or just in GitHub Issues) to log and track API changes, feature requests, and bugs.